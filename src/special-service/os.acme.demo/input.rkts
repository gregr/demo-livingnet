(resolve-dependencies ()
 (lambda (get)
   (define (to-sym val) (string->symbol (format "~a" val)))
   (fn (goals)
       (values _ finished) =
       (let loop ((seen (set)) (finished '()) (localhost #f) (targets goals))
         (forf seen = seen finished = finished target <- targets
               (list host stgt) = target
               host = (or host localhost)
               (if (set-member? seen target) (values seen finished)
                 (lets (list deps code) = (get host stgt)
                       (values seen finished) =
                       (loop (set-add seen target) finished host deps)
                       binding = `(,(to-sym target)
                                    (,code ,@(map to-sym deps)))
                       (values seen (list* binding finished))))))
       `(let* ,(reverse finished) (list ,@(map to-sym goals)))))

  network-connector ()
  (lambda (network host) (thunk (o@ network 'connect host)))

  network-serve ()
  (lambda (network serve)
    (letn loop (values) = (values)
          conn = (o@ network 'accept)
          _ = (thread (thunk (serve conn)))
          (loop)))
  serve-requests ()
  (lambda (request->response)
    (lambda (conn)
      (letn loop (values) = (values)
            request = (o@ conn 'get)
            (unless (void? request)
              (o@ conn 'put (request->response request))
              (loop)))))
  network-serve-requests (network-serve serve-requests)
  (lambda (network request->response)
    (network-serve network (serve-requests request->response)))

  port/input ()
  (class self (in) () ()
         (close () (close-input-port in))
         (get-char () (read-char in))
         (get-line () (read-line in))
         (get-eof () (let loop ((lines '()))
                       (match (o@ self 'get-line)
                         ((? eof-object?) (string-join (reverse lines) "\n"))
                         (line (loop (list* line lines))))))
         (port () in))
  port/output ()
  (class _ (out) () ()
         (close () (close-output-port out))
         (put (value) (display value out))
         (put-line (value) (displayln value out) (flush-output out))
         (flush () (flush-output out))
         (port () out))
  channel/input ()
  (class _ (in) () () (get () (read/no-eof in)))
  channel/output ()
  (class _ (out) () () (put (value) (write value out)))
  socket ()
  (lambda (getter putter) (object '(getter putter)))
  raw-ports->console (port/input port/output)
  (lambda (in out) (object (list (port/input in) (port/output out))))

  file ()
  (class _ (storage path) () ()
         (get () (o@ storage 'get path))
         (put (value) (o@ storage 'put path value))
         (delete () (o@ storage 'delete path)))

  read-only ()
  (lambda (parent)
    (object '() (method-table _ (get args (o@* parent 'get args)))))
  write-only ()
  (lambda (parent)
    (object '() (method-table _
                              (put args (o@* parent 'put args))
                              (delete args (o@* parent 'delete args)))))
  storage/sub ()
  (class _ (parent root) ((subroot (append (o@ parent 'root) root)))
         (parent)
         (root () subroot))

  download ()
  (fn (net hostname request)
      conn = (o@ net 'connect hostname)
      _ = (o@ conn 'put request)
      response = (o@ conn 'get)
      _ = (o@ conn 'delete)
      ; TODO: faithful implementation would 'get' until response is void
      _ = (o@ conn 'close)
      response)

  cache-put ()
  (lambda (fsys path data time-added cache-duration)
    (o@ fsys 'put path (list time-added cache-duration data)))
  cache-get (cache-put)
  (lambda (fsys path origin-get cache-duration)
    (lets now = (current-seconds)
          cache-entry = (o@ fsys 'get path)
          (values cached? data) =
          (if (void? cache-entry)
            (values #f (void))
            (lets (list time-added duration data) = cache-entry
                  cache-duration =
                  (if cache-duration
                    (if duration (min duration cache-duration)
                      cache-duration)
                    duration)
                  (if (and duration (<= (+ time-added duration) now))
                    (values #f (void)) (values #t data))))
          (if cached? data
            (lets data = (origin-get)
                  _ = (unless (void? data)
                        (cache-put fsys path data now cache-duration))
                  data))))
  ; TODO: split request string to avoid filenames that are too long
  signature->path ()
  (lambda (hostname request) (list hostname (format "~v" request)))

  get-resource (download cache-get signature->path)
  (lambda (net fsys)
    (define (get host request cache-duration)
      (cache-get fsys (signature->path host request)
                 (thunk (download net host request)) cache-duration))
    (lambda (self-host)
      (lambda (host request (cache-duration #f))
        (if (or (not host) (equal? self-host host))
          (get self-host request cache-duration)
          (get host request #f)))))

  negotiate (download cache-get signature->path)
  (lambda (net fsys eval)
    (fn (hostname request)
        code = (cache-get fsys (signature->path hostname request)
                          (thunk (void)) #f)
        code = (if (void? code) (download net hostname request) code)
        (with-handlers ((exn:fail? identity)) (eval code))))

  global-network ()
  (let ((connection (class _ (conn) () ()
                           (close () (network-close conn))
                           (delete () (network-shutdown conn))
                           (put (value) (network-send conn value))
                           (get () (network-recv conn)))))
    (object
      '()
      (method-table
        _
        (accept () (connection (network-accept)))
        (connect (hostname) (connection (network-connect hostname))))))
  global-storage ()
  (lets subpath = (lambda (self path) (append (o@ self 'root) path))
        (object
          '()
          (method-table
            self
            (root () '())
            (get (path) (storage-get (subpath self path)))
            (put (path value) (storage-put (subpath self path) value))
            (delete (path) (storage-delete (subpath self path))))))
  master-boot-record (file global-storage)
  (file global-storage (list "master-boot-record"))
  global-filesystem (storage/sub global-storage)
  (storage/sub global-storage (list "data"))
 global-console (raw-ports->console)
 (raw-ports->console (current-input-port) (current-output-port))

 global-get (storage/sub get-resource global-network global-filesystem)
 (get-resource global-network (storage/sub global-filesystem
                                           (list "cache" "get")))
 global-negotiate (storage/sub negotiate global-network global-filesystem)
 (curry negotiate global-network (storage/sub global-filesystem
                                              (list "cache" "negotiate")))

 pipe-console (raw-ports->console)
 (fn ()
   (values inner-in to-inner) = (make-pipe)
   (values from-inner inner-out) = (make-pipe)
   inner-console = (raw-ports->console inner-in inner-out)
   outer-console = (raw-ports->console from-inner to-inner)
   (values inner-console outer-console))

 capabilities->context ()
 (lambda (cap-hash) (lambda (cap-key)
                      (hash-ref cap-hash cap-key (thunk (void)))))
 capabilities-basic
 (storage/sub global-get global-negotiate global-network global-filesystem)
 (let ()
   (define (host->fsys host)
     (storage/sub global-filesystem (list "application-data" host)))
   (define (host->network net self-host)
     (object '()
             (method-table _
                           (connect (host) (if (equal? self-host host)
                                             (o@ net 'connect host) (void))))))
   (define (capabilities-basic host console)
     (hash 'console console
           'network (host->network global-network host)
           'filesystem (host->fsys host)
           'get (global-get host)
           'negotiate global-negotiate))
   capabilities-basic))
